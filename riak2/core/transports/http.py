from exceptions import ConnectionError, RiakError
from transport import Transport
from connection import ConnectionManager
import errno
import urllib
import csv
import re
import json
import socket
from httplib import HTTPException

# This module is designed to function independently of the entire library.
# For easier intergration.

# MAX_LINK_HEADER_SIZE = 8184

class HttpTransport(Transport):
    api = 2
    RETRY_COUNT = 3

    def make_put_header(self, content_type, links, indexes, metadata, vclock=None):
        """Creates a header for put. This is done so that the function arguments
        for put is not too crazy, and it also gives you a chance to manipulate
        the headers if required.

        :param content_type: Content type
        :param links: A list of 3 item tuples for links, consisting of bucket, key, tag
        :param indexes: A list of 2 item tuples for 2i, consisting of field, value
        :param metadata: A dictionary of metadata
        :param vclock: Vector clock data.
        :rtype: A dictionary of a fully constructed header.
        """
        headers = {
            "Accept" : "text/plain, */*; q=0.5",
            "X-Riak-ClientId" : self.client_id,
            "Content-Type" : content_type
        }

        if vclock:
            headers["X-Riak-Vclock"] = vclock

        for key, value in metadata.iteritems():
            headers["X-Riak-Meta-%s" % key] = value

        for field, value in indexes:
            key = "X-Riak-Index-%s" % field
            if key in headers:
                headers[key] += ", " + value
            else:
                headers[key] = value

        for bucket, key, tag in links:
            link = self._to_link_header(bucket, key, tag)
            if "Link" in headers:
                headers["Link"] += ", " + link
            else:
                headers["Link"] = link

        return headers

    def __init__(self, cm=None, prefix="riak", mapred_prefix="mapred",
                 client_id=None, **unused_options):
        if cm is None:
            cm = ConnectionManager.get_http_cm()
        self._connections = cm
        self._prefix = prefix
        self._mapred_prefix = mapred_prefix

        self.client_id = client_id or self.random_client_id()

    def ping(self):
        """Check if server is alive over HTTP.

        :rtype: Returns a boolean.
        """
        response = self._request("GET", "/ping")
        return response[1] == "OK"

    def get(self, bucket, key, r, vtag=None):
        """Get from the database.

        :param bucket: The bucket name.
        :type bucket: string
        :param key: The key name
        :type key: string
        :param r: The R value
        :type r: integer
        :param vtag: The vector clock value.
        :rtype: Returns vclock, metadata, data in a 3 item tuple. Or None if the
                object is not found. or a list of siblings if that's requested.
        """
        params = {"r" : r}
        if vtag is not None:
            params["vtag"] = vtag
        url = self._build_rest_path(bucket, key, params=params)
        response = self._request("GET", url)
        return self._parse_response(response, 200, 300, 404)

    def put(self, bucket, key, content, headers, w, dw, return_body=True):
        """Puts an object into the database

        If key is None, a key will be generated by riak.

        :param bucket: The bucket name.
        :type bucket: string
        :param key: The key name
        :type key: string or None
        :param content: The content/body for the PUT/POST request
        :type content: string
        :param headers: The headers for the PUT/POST request. Usually constructed using :func: `make_put_header`
        :type headers: dictionary
        :param w: The W value.
        :param dw: The DW value
        :param return_body: Return the body/meta or not. Defaults to True
        :rtype: Returns a 3 item tuple depending on the input. If key is None,
                it will return the key as the first item of the tuple, the
                vclock, metadata as the 2nd and 3rd if return_body is True.
                Otherwise those 2 elements will be None.
                If key is not None, returns vclock, metadata, data if
                return_body is True. Otherwise returns 3 None.
        """
        params = {
                    "returnbody" : "true" if return_body else "false",
                    "w" : w,
                    "dw" : dw
                }
        url = self._build_rest_path(bucket, key, params=params)

        if key is None:
            response = self._request("POST", url, headers, content)
            location = response[0]["location"]
            idx = location.rindex("/")
            key = location[idx+1:]
            if return_body:
                vclock, metadata, data = self._parse_response(response, 201)
                return key, vclock, metadata
            else:
                self._assert_http_code(response, 201)
                return key, None, None
        else:
            response = self._request("PUT", url, headers, content)
            if return_body:
                return self._parse_response(response, 200, 201, 300)
            else:
                self._assert_http_code(response, 204)
                return None, None, None

    def delete(self, bucket, key, rw):
        """Deletes an object from the database.

        :param bucket: The bucket name.
        :param key: The key name
        :param rw: RW value.
        """
        params = {"rw" : rw}
        url = self._build_rest_path(bucket, key, params)
        self._assert_http_code(self._request("DELETE", url), 204, 404)

    def _get_stuff(self, bucket, params):
        url = self._build_rest_path(bucket)
        response = self._request("GET", url)
        self._assert_http_code(response, 200)
        return json.loads(response[1])

    def get_keys(self, bucket):
        """Gets a list of keys from the database.

        Not recommended for production as it is very very slow! Requires
        traversing through ALL keys in the cluster regardless of the bucket"s
        key size.

        :param bucket: The bucket name
        :rtype: A list of keys.
        """
        return self._get_stuff(bucket, {"keys" : "true"})["keys"]

    def get_buckets(self):
        """Get a list of bucket from the database.

        Note recommended for production as it is very very slow! Requires
        traversing through the entire set of keys.

        :rtype: A list of buckets from the database"""
        return self._get_stuff(None, {"buckets" : "true"})["buckets"]

    def get_bucket_properties(self, bucket):
        """Get a list of bucket properties.

        :param bucket: The bucket name
        :rtype: A dictionary of bucket properties.
        """
        return self._get_stuff(bucket, {"props" : "true", "keys" : "false"})["props"]

    def set_bucket_properties(self, bucket, properties):
        """Sets bucket properties. Raises an error if fails.

        :param bucket: The bucket name
        :param properties: A dictionary of properties
        """
        url = self._build_rest_path(bucket)
        headers = {"Content-Type" : "application/json"}
        content = json.dumps({"props" : props})
        response = self._request("PUT", url, headers, content)

        self._assert_http_code(response, 204)

    def mapreduce(self, inputs, query, timeout=None):
        """Map reduces on the database.

        :param input: The input
        :param query: The query dictionary
        :param timeout: Timeout values.
        :rtype: A list of results"""
        job = {"inputs": inputs, "query": query}
        if timeout is not None:
            job["timeout"] = timeout
        content = json.dumps(job)
        url = "/" + self._mapred_prefix
        response = self._request("POST", url, {}, content)
        self._assert_http_code(response, 200)
        return json.loads(response[1])

    def _build_rest_path(self, bucket=None, key=None, params=None, prefix=None):
        # Build "http://hostname:port/prefix/bucket"
        path = "/" + (prefix or self._prefix)
        if bucket is not None:
            path += "/" + urllib.quote_plus(bucket)

        if key is not None:
            path += "/" + urllib.quote_plus(key)

        if params is not None:
            s = ""
            for k in params.keys():
                if s != "": s += "&"
                s += urllib.quote_plus(k) + "=" + urllib.quote_plus(str(params[k]))
            path += "?" + s

        return path

    def _request(self, method, url, headers=None, body=""):
        if headers is None: headers = {}

        for retry in xrange(self.RETRY_COUNT):
            with self._connections.withconn() as conn:
                try:
                    response = conn.request(method, url, body, headers)
                    response = conn.getresponse()
                    try:
                        response_headers = {"http_code" : response.status}
                        for key, value in response.getheaders():
                            response_headers[key.lower()] = value
                        response_body = response.read()
                        return response_headers, response_body
                    finally:
                        response.close()
                except socket.error, e:
                    conn.close()
                    if e[0] == errno.ECONNRESET:
                        continue
                    raise e
                except HTTPException, e:
                    conn.close()
                    continue

        # Raise the last error
        raise e or ConnectionError("Some strange error has occured")

    def _assert_http_code_is_not(self, response, *unexpected_status):
        status = response[0]["http_code"]
        if status in unexpected_status:
            raise ConnectionError("Unexpected Status: %s" % str(status))

    def _assert_http_code(self, response, *expected_status):
        status = response[0]["http_code"]
        if not status in expected_status:
            raise ConnectionError("Expected Status: %s | Received: %s" % (str(expected_status), response))

    def _parse_response(self, response, *expected_status):
        if response is None:
            return self

        self._assert_http_code(response, *expected_status)

        headers, data = response
        status = headers["http_code"]

        if status == 404:
            return None
        elif status == 300:
            siblings = data.strip().split("\n")
            siblings.pop(0)
            return siblings

        vclock = None
        metadata = {"usermeta" : {}, "index" : []}
        links = []

        for header, value in headers.iteritems():
            if header == "x-riak-vclock":
                vclock = value
            elif header.startswith("x-riak-meta-"):
                metadata["usermeta"][header[12:]] = value
            elif header.startswith("x-riak-index-"):
                field = header.replace("x-riak-index-", "")
                reader = csv.reader([value], skipinitialspace=True)
                for line in reader:
                    for token in line:
                        metadata["index"].append((field, token))
            elif header == "link":
                links.extend(self._parse_links(value))
            else:
                metadata[header] = value

        if links:
            metadata["link"] = links

        return vclock, metadata, data

    _link_regex = re.compile("</([^/]+)/([^/]+)/([^/]+)>; ?riaktag=\"([^\']+)\"")
    def _parse_links(self, links):
        """returns bucket, key, tag"""
        new_links = []
        for link_header in links.strip().split(','):
            link_header = link_header.strip()
            matches = self._link_regex.match(link_header)
            if matches is not None:
                # bucket, key, tag
                new_links.append((matches.group(2),
                                  matches.group(3),
                                  matches.group(4)))
        return new_links

    def _to_link_header(self, bucket, key, tag):
        header = '</'
        header += self._prefix + '/'
        header += urllib.quote_plus(bucket) + '/'
        header += urllib.quote_plus(key) + '>; riaktag="'
        header += urllib.quote_plus(tag) + '"'
        return header


